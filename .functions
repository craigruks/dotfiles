#!/bin/bash

# since brew cask update doesn't exist yet, this is an adhoc way thanks to
# https://gist.github.com/tonyseek/afa5902eb2713ca6cfab
function cask_update() {
  set -e

  STAGING_LOCATION="$(brew cask doctor \
      | grep -A1 '==> Homebrew-cask Staging Location:' | tail -n1 \
      | awk '{print $1}')"

  echo "==> Upgrading casks"
  for cask in $(ls ${STAGING_LOCATION})
  do
      case "${cask}" in
          tunnelblick)
              echo "Skip ${cask}"
              ;;
          *)
              brew cask install "${cask}"
              ;;
      esac
  done

  echo "==> Uninstalling casks"
  _trash() {
      if [ -z "$(command -v trash)" ]
      then
          echo >&2 "Please install trash: brew install trash"
          exit 1
      fi
      if [ -e "$1" ]
      then
          trash "$1"
          echo "trash $1: success"
      else
          echo "trash $1: missing"
      fi
  }
  _list_old_versions() {
      for path in "$@"
      do
          if [ -e "$1" ]
          then
              ls -1tr "$1" | sed '$d'
          fi
      done
  }
  for cask in $(ls ${STAGING_LOCATION})
  do
      for version in $(_list_old_versions \
              "${STAGING_LOCATION}/${cask}" \
              "${STAGING_LOCATION}/${cask}/.metadata")
      do
          echo "Clean ${cask} ${version}"
          _trash "${STAGING_LOCATION}/${cask}/${version}"
          _trash "${STAGING_LOCATION}/${cask}/.metadata/${version}"
      done
  done
}

# cd into whatever is the forefront Finder window.
function cdf() {  # short for cdfinder
  cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}

# Copy w/ progress
function cp_p () {
  rsync -WavP --human-readable --progress $1 $2
}

# Extract archives - use: extract <file>
# Based on http://dotfiles.org/~pseup/.bashrc
function extract() {
  if [ -f "$1" ] ; then
    local filename=$(basename "$1")
    local foldername="${filename%%.*}"
    local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
    local didfolderexist=false
    if [ -d "$foldername" ]; then
      didfolderexist=true
      read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
      echo
      if [[ $REPLY =~ ^[Nn]$ ]]; then
        return
      fi
    fi
    mkdir -p "$foldername" && cd "$foldername"
    case $1 in
      *.tar.bz2) tar xjf "$fullpath" ;;
      *.tar.gz) tar xzf "$fullpath" ;;
      *.tar.xz) tar Jxvf "$fullpath" ;;
      *.tar.Z) tar xzf "$fullpath" ;;
      *.tar) tar xf "$fullpath" ;;
      *.taz) tar xzf "$fullpath" ;;
      *.tb2) tar xjf "$fullpath" ;;
      *.tbz) tar xjf "$fullpath" ;;
      *.tbz2) tar xjf "$fullpath" ;;
      *.tgz) tar xzf "$fullpath" ;;
      *.txz) tar Jxvf "$fullpath" ;;
      *.zip) unzip "$fullpath" ;;
      *.7z) 7z x "$fullpath" ;;  # requires brew p7zip!
      *) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# find shorthand
function f() {
  find . -name "$1" 2>&1 | grep -v 'Permission denied'
}

# generate shortened github link
function gitio() {
  curl -i "https://git.io" -F "url=$1"
}

# get gzipped size
function gz() {
  echo "orig size    (bytes): "
  cat "$1" | wc -c
  echo "gzipped size (bytes): "
  gzip -c "$1" | wc -c
}

function localip() {
  function _localip() { echo "ðŸ“¶  "$(ipconfig getifaddr "$1"); }
  export -f _localip
  local purple="\x1B\[35m" reset="\x1B\[m"
  networksetup -listallhardwareports | \
    sed -r "s/Hardware Port: (.*)/${purple}\1${reset}/g" | \
    sed -r "s/Device: (en.*)$/_localip \1/e" | \
    sed -r "s/Ethernet Address:/ðŸ“˜ /g" | \
    sed -r "s/(VLAN Configurations)|==*//g"
}

# written by craigruks
# toggles showing/hiding hidden files, auto restarts Finder as well
function hidden_toggle() {
  show=0
  new_state='Files now hidden'

  if [ `defaults read com.apple.finder AppleShowAllFiles` -eq "0" ]; then
    new_state='Files now showing'
    show=1
  fi

  defaults write com.apple.finder AppleShowAllFiles ${show}
  killall "Finder" > /dev/null 2>&1

  echo ${new_state}
}

# if i need php versions in the future...
# https://github.com/wilmoore/php-version

# spoof MAC address for security
# based on http://osxdaily.com/2012/03/01/change-mac-address-os-x/
# run `sudo ifconfig en0 ether xx:xx:xx:xx:xx:xx` to reset
function spoofmac () {
  openssl rand -hex 1 | tr '[:lower:]' '[:upper:]' | xargs echo "obase=2;ibase=16;" | bc | cut -c1-6 | sed 's/$/00/' | xargs echo "obase=16;ibase=2;" | bc | sed "s/$/:$(openssl rand -hex 5 | sed 's/\(..\)/\1:/g; s/.$//' | tr '[:lower:]' '[:upper:]')/" | xargs sudo ifconfig en0 ether;
}

# Load NVM
function start_nvm() {
  # associate dir and run startup shell script
  export NVM_DIR="$HOME/.nvm"
  [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"

  # useful shortcuts
  alias npml='npm list $@ | grep ^[â”œâ””]'  # list top level npm packages
  alias npmgl='npm -g list $@ | grep ^[â”œâ””]'  # list top level npm packages globally
  alias nvm_use_default='nvm use default node'  # use default version of node
}

# Load ruby rbenv
function start_rbenv() {
  eval "$(rbenv init -)"
  export RBENV="true"  # used in .bash_prompt to know when to show ruby version
}

# Load python virtualenvwrapper
function start_virtualenvwrapper() {
  export WORKON_HOME=~/.virtualenvs
  export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python
  export VIRTUALENVWRAPPER_VIRTUALENV_ARGS='--no-site-packages'
  source /usr/local/bin/virtualenvwrapper.sh

  # don't show prompt bc it's already in custom prompt
  export VIRTUAL_ENV_DISABLE_PROMPT=1

  # make python3 virtualenv
  alias mkvirtualenv3='mkvirtualenv --python=/usr/local/bin/python3 '
}

# Decode \x{ABCD}-style Unicode escape sequences
# from troyxmccall/dotfiles
function unidecode() {
  perl -e "binmode(STDOUT, ':utf8'); print \"$@\"";
  # print a newline unless weâ€™re piping the output to another program
  if [ -t 1 ]; then
    echo ""; # newline
  fi;
}

# whois a domain or a URL
function whois() {
  local domain=$(echo "$1" | awk -F/ '{print $3}') # get domain from URL
  if [ -z $domain ] ; then
    domain=$1
  fi
  echo "Getting whois record for: $domain â€¦"

  # avoid recursion
  # this is the best whois server
  # strip extra fluff
  /usr/bin/whois -h whois.internic.net $domain | sed '/NOTICE:/q'
}
